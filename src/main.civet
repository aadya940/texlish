// based on https://github.com/DanielXMoore/Civet/blob/main/source/main.civet

import { parse, getStateKey, state } from "./parser.hera"
//import * as sourcemap from "./sourcemap.civet"
//{ SourceMap } := sourcemap
export { parse }

import { markdownText } from "./markdown.civet"

import StateCache from "./state-cache.civet"

// Need to no-cache any rule that directly modifies parser state
// indentation stack, jsx stack, etc.

uncacheable := new Set [
  // Indentation
  // We need to no-cache the state modifying rules up to the point where they
  // balance within a parent so PushIndent needs to be marked no-cache even
  // though it only calls TrackIndented which does the actual work.
  "Indent"
  "PushIndent"
  "PopIndent"
  "SaveIndent"
]

export type CompilerOptions
  filename?: string
  ast?: boolean
  trace?: string

export type AST = undefined | string | { token: string } | AST[]

export function generate(ast: AST): string
  if ast <? "string"
    ast
  else if not ast?
    ''
  else if Array.isArray ast
    ast.map(generate).join ''
  else if "token" in ast
    ast.token
  else
    throw new Error `Unrecognized token ${ast}`

export function compile<const T extends CompilerOptions>(src: string, options?: T): string
  unless options
    options = {} as T
  else
    options = {...options}

  filename := options.filename or "unknown"

  events := makeCache options

  let ast
  try
    ast = parse(src, {
      filename
      events
    })
  finally
    if trace := options.trace
      import('node:fs').then ({ writeFileSync }) =>
        { logs } := events.meta
        writeFileSync trace, logs.join "\n"

  return ast if options.ast

  ast
  |> generate
  |> markdownText ., state.styles

type MetaData
  logs: string[]

type CacheKey = [number, number, string]

type ParseState =
  input: string
  pos: number

type ParseResult = {
  pos: number
  value: unknown
} | undefined

type CacheEvents
  meta: MetaData
  enter: (ruleName: string, state: ParseState) => { cache: ParseResult } | undefined
  exit: (ruleName: string, state: ParseState, result: ParseResult) => void

function makeCache(options: CompilerOptions): CacheEvents
  stateCache := new StateCache<ParseResult>

  { trace } := options
  logs: string[] := []
  stack: string[] := []
  meta: MetaData := { logs }

  events := {
    meta
    enter(ruleName: string, state: ParseState)
      return if uncacheable.has(ruleName)

      stateKey := getStateKey()
      key: CacheKey := [stateKey, state.pos, ruleName ]

      // We cache `undefined` when a rule fails to match so we need to use `has` here.
      if stateCache.has(key)
        result := stateCache.get(key)
        if trace
          logs.push "".padStart(stack# * 2, " ") + ruleName + ":" + state.pos + "üí∞" + (if result then "‚úÖ" else "‚ùå")
        return {
          cache: if result then { ...result }
        }

      if trace
        logs.push "".padStart(stack# * 2, " ") + ruleName + ":" + state.pos + "\u2192"
        stack.push ruleName
      return

    exit(ruleName: string, state: ParseState, result: ParseResult): void
      return if uncacheable.has(ruleName)
      stateKey := getStateKey()
      key: CacheKey := [stateKey, state.pos, ruleName ]
      stateCache.set(key, result)

      if trace
        stack.pop()
        logs.push "".padStart(stack.length * 2, " ") + ruleName + ":" + state.pos + " " + (if result then "‚úÖ" else "‚ùå")
  }

  return events
