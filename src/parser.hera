```
export const state = {
  get currentIndent() {
    return state.indents.at(-1)
  }
}
export function getStateKey() {
  return 0
}
```

Main
  Init Program

Init
  "" ->
    state.indents = [ { token: '', level: 0 } ]

Program
  ( Statement EOL )*

EOL
  /\n|\r\n?|$/

Statement
  Header
  Environment
  CommandWithNestedArgument
  UnorderedList
  OrderedList
  TextLine

TextLine
  Indent Text InlineCommandWithNestedArgument?

Text
  TextPart*

TextPart
  /@=([^\s]+)/ ->
    return `\\label{${$1}}`
  /@([^\s=][^\s]*)/ ->
    return `\\ref{${$1}}`
  /\[\[(.*?)\]\]/ ->
    return `\\cite{${$1}}`
  !InlineCommandWithNestedArgument /[^\r\n][^\r\n@\[\\]*/ ->
    return $2[0]

TrimmedText
  Text:t ->
    if (!t.length) return t
    if (t.length === 1) return [ t[0].trim() ]
    return [
      t[0].trimStart(),
      ...t.slice(1, -1),
      t.at(-1).trimEnd(),
    ]

Header
  /(#+)(\*?)\s+/ TrimmedText:title ->
    let [, hash, star] = $1
    let level = hash.length - 1
    let command =
      level === 0 ? '\\chapter' :
      level <= 3 ? `\\${'sub'.repeat(level)}section` :
      level === 4 ? '\\paragraph' : '\\subparagraph'
    if (star) command += '*'
    return `${command}{${title}}`

Environment
  &/[ \t]*>/ Indent:indent />\s*((?:[^:\s]+|:(?!\s))+):?/:env TrimmedText:first NestedBody:body ->
    env = env[1].trim()
    return [
      indent,
      `\\begin{${env}}`,
      first,
      body,
      "\n",
      indent,
      `\\end{${env}}`,
    ]

CommandWithNestedArgument
  Indent:indent /(\\[^:\s]+):/:command NonEmptyNestedBody:body ->
    command = command[1]
    return [
      indent,
      command,
      "{%",
      body,
      "\n",
      indent,
      "}%",
    ]

InlineCommandWithNestedArgument
  SaveIndent:indent /(\\[^:\s]+):/:command NonEmptyNestedBody:body ->
    command = command[1]
    return [
      command,
      "{%",
      body,
      "\n",
      indent,
      "}%",
    ]

NonEmptyNestedBody
  NestedBody ->
    if (!$1.length) return $skip
    return $1

NestedBody
  PushIndent NestedItem* PopIndent

NestedItem
  Nested Statement

UnorderedList
  UnorderedBullet PushIndent ( SameLevel UnorderedBullet )* PopIndent ->
    let indent = $1[0]
    return [
      indent,
      "\\begin{itemize}",
      "\n",
      $0,
      "\n",
      indent,
      "\\end{itemize}",
    ]

UnorderedBullet
  Indent:indent /[*\-]([ \t]+)/ Text:text NestedBody:body ->
    let space = $2[1]
    return [ indent, '\\item', space, text, body ]

OrderedList
  OrderedBullet PushIndent ( SameLevel OrderedBullet )* PopIndent ->
    let indent = $1[0]
    return [
      indent,
      "\\begin{enumerate}",
      "\n",
      $0,
      "\n",
      indent,
      "\\end{enumerate}",
    ]

OrderedBullet
  Indent:indent /\d+\.([ \t]+)/ Text:text NestedBody:body ->
    let space = $2[1]
    return [ indent, '\\item', space, text, body ]

## Indentation management, inspired by Civet's parser.hera

Indentation
  /[ \t]*/ ->
    const numTabs = $0.match(/\t/g)?.length ?? 0
    const level = numTabs * 8 + ($0.length - numTabs)
    return { $loc, token: $0, level }

Indent
  Indentation ->
    return state.thisLineIndent = $1

PushIndent
  "" ->
    //const {level} = indent
    //if (level < state.currentIndent.level) return $skip
    state.indents.push(state.thisLineIndent)

PopIndent
  "" ->
    state.indents.pop()

Nested
  EOL &IndentedFurther -> $1

IndentedFurther
  Indentation:indent ->
    if (indent.level <= state.currentIndent.level) return $skip
    return $0

SameLevel
  EOL &IndentedSame -> $1

IndentedSame
  Indentation:indent ->
    if (indent.level !== state.currentIndent.level) return $skip
    return $0

SaveIndent
  "" ->
    return state.thisLineIndent
