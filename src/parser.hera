```
import { generate } from './main.civet'

export const state = {
  get currentIndent() {
    return state.indents.at(-1)
  }
}
export function getStateKey() {
  return 0
}
```

Main
  Init Content

Init
  "" ->
    state.indents = [ { token: '', level: 0 } ]
    state.styles = {
      '*': '\\emph',
      '**': '\\textbf',
      '***': '\\defn',
      '@=': '\\label',
      '@': '\\ref',
      '#@': '\\pageref',
      '[[': '\\cite',
    }

Content
  Statement ( EOL Statement )*
  "" -> []

EOL
  /[ \t]*(\n|\r\n?|$)/

Statement
  Header
  MetaBlock
  Environment
  CommandWithColonArgument
  UnorderedList
  OrderedList
  TextLine

# One line of text, with leading indentation and maybe trailing colon argument
# (can be empty, no newline)
TextLine
  Indent Text InlineCommandWithColonArgument?

# One line of text, without leading indentation or trailing nested argument
# (for inline uses, can be empty, no newline)
Text
  TextPart*

TextPart
  BracedContent
  /(@=|@|#@)([^\s]+)/ ->
    return `${state.styles[$1]}{${$2}}`
  /\[\[(.*?)\]\]/ ->
    return `${state.styles['[[']}{${$1}}`
  /([\^_])(\d{2,}|[a-zA-Z]{2,})/ ->
    return `${$1}{${$2}}`
  [\^_] ParenthesizedContent ->
    // $2[1] strips the parens
    return [ $1[0], '{', $2[1], '}' ]
  # Leave trailing InlineCommandWithColonArgument for TextLine to parse
  !InlineCommandWithColonArgument Command -> $2
  # Skip to next interesting character
  /[^\r\n\\][^\r\n@#\[\\\^_{}()]*/

TrimmedText
  Text:t ->
    if (!Array.isArray(t)) return t.trim()
    t = [...t]
    if (typeof t[0] === 'string') t[0] = t[0].trimStart()
    const last = t.length - 1
    if (typeof t[last] === 'string') t[last] = t[last].trimEnd()
    return t

BracedContent
  "{" Content "}"

Command
  /\\[a-zA-Z@]+/
  /\\./

ParenthesizedContent
  "(" ParenBalancedContent ")"

ParenBalancedContent
  ParenthesizedContent
  TextPart

Header
  /(#+)(\*?)\s+/ TrimmedText:title ->
    let [, hash, star] = $1
    let level = hash.length - 1
    let command =
      level === 0 ? '\\chapter' :
      level <= 3 ? `\\${'sub'.repeat(level)}section` :
      level === 4 ? '\\paragraph' : '\\subparagraph'
    if (star) command += '*'
    return [ command, '{', title, '}' ]

Environment
  &/[ \t]*>/ Indent:indent />[ \t]*([^:\s]+)/:env TrimmedText:first NestedBody:body ->
    env = env[1].trim()
    return [
      indent,
      `\\begin{${env}}`,
      first,
      body,
      "\n",
      indent,
      `\\end{${env}}`,
    ]

CommandWithColonArgument
  Indent:indent InlineCommandWithColonArgument:rest ->
    return [
      indent,
      rest,
    ]

InlineCommandWithColonArgument
  CommandColon:command ColonArgument:arg ->
    return [
      command,
      arg,
    ]

ColonArgument
  NestedArgumentList
  NonEmptyNestedBody:body ->
    return [
      "{%",
      body,
      "}%",
    ]
  TrimmedText:body ->
    return [
      "{",
      body,
      "}%",
    ]

CommandColon
  /(\\[^:\s]+):/ -> $1

MetaBlock
  &/[ \t]*>>/ Indent:indent ">>" MetaCommand:cmd -> cmd

MetaCommand
  "styles" NestedAssignments:body ->
    for (const [key, value] of body) {
      state.styles[key] = generate(value)
    }
    return '\0'  // eat following newline

NestedAssignments
  PushIndent NestedAssignment*:items PopIndent ->
    if (!items.length) return $skip
    return items

NestedAssignment
  Nested Indent /[^\s:]+/:key /\s+:?=\s*/ Text:value ->
    return [ key[0], value ]

NonEmptyNestedBody
  NestedBody ->
    if (!$1.length) return $skip
    return $1

NestedBody
  PushIndent NestedItem* PopIndent -> $2

NestedItem
  Nested Statement

UnorderedList
  UnorderedBullet PushIndent ( SameLevel UnorderedBullet )* PopIndent ->
    let indent = $1[0]
    return [
      indent,
      "\\begin{itemize}",
      "\n",
      $0,
      "\n",
      indent,
      "\\end{itemize}",
    ]

UnorderedBullet
  Indent:indent /[*\-~]([ \t]+)/ Text:text NestedBody:body ->
    let space = $2[1]
    return [ indent, '\\item', space, text, body ]

OrderedList
  OrderedBullet PushIndent ( SameLevel OrderedBullet )* PopIndent ->
    let indent = $1[0]
    return [
      indent,
      "\\begin{enumerate}",
      "\n",
      $0,
      "\n",
      indent,
      "\\end{enumerate}",
    ]

OrderedBullet
  Indent:indent /\d+\.([ \t]+)/ Text:text NestedBody:body ->
    let space = $2[1]
    return [ indent, '\\item', space, text, body ]

NestedArgumentList
  PushIndent NonstrictlyNested:nested ArgumentList?:list PopIndent ->
    if (!list) return $skip
    return [ nested, list ]

ArgumentList
  &/\s*[*\-~]/ PushIndent ( ArgumentBullet ( SameLevel ArgumentBullet )* )?:content PopIndent ->
    return content

ArgumentBullet
  Indent:indent /([*\-~])([ \t]+)/ Text:text NestedBody:body ->
    let [ , bullet, space ] = $2
    return [
      indent,
      ' '.repeat(space.length),
      bullet === '~' ? '[' : '{',
      text,
      body,
      bullet === '~' ? ']%' : '}%',
    ]

## Indentation management, inspired by Civet's parser.hera

Indentation
  /[ \t]*/ ->
    const numTabs = $0.match(/\t/g)?.length ?? 0
    const level = numTabs * 8 + ($0.length - numTabs)
    return { $loc, token: $0, level }

Indent
  Indentation ->
    return state.thisLineIndent = $1

PushIndent
  "" ->
    //const {level} = indent
    //if (level < state.currentIndent.level) return $skip
    state.indents.push(state.thisLineIndent)

PopIndent
  "" ->
    state.indents.pop()

Nested
  EOL &IndentedFurther -> $1

IndentedFurther
  Indentation:indent ->
    if (indent.level <= state.currentIndent.level) return $skip
    return $0

SameLevel
  EOL &IndentedSame -> $1

IndentedSame
  Indentation:indent ->
    if (indent.level !== state.currentIndent.level) return $skip
    return $0

NonstrictlyNested
  EOL &IndentedNotLess -> $1

IndentedNotLess
  Indentation:indent ->
    if (indent.level < state.currentIndent.level) return $skip
    return $0

SaveIndent
  "" ->
    return state.thisLineIndent
